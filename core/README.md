This directory holds the "core" Rune compiler.  It only recognizes the "core"
list form of Rune code, and only low-level forms that can be directly
translated to C code.  The core syntax is low-level, but still hides memory
layout.  There are new and delete operators to allocate/free objects on the
heap.  Destructors have been fully auto-generated by this point.  The only
global object is "root".  There are no collections, and instead only the
primitive built-in types:

  - ints, floats, utf-8 string, char (utf-8 encoded)
  - fixed and dynamic arrays
  - structs
  - object references
  - slices?

The probje I ran into during identifier binding is that we have to know Tthe
type of an expression to be able to use the dot operator on it.  A method or
function call returns an expression of a given type, and the following dot
operator needs the result of the type binding to work.  Type binding must be
done at the same time as identier binding.

It would be nice to have a simple core syntax that encodes both scoping and
type structure.  Expressions are already expanded into generic function calls
before type and identifier and type binding.  To match a generic function in a
scope, we recursively bind the types of the parameters.  If we have seen this
signature before, we get the type from the previous instantiation of the
function.  

We need to do type/identifier binding before conversion to core syntax.

There are two groups of identifiers: declaration idents, and reference idents.
Declaration idents declare scopes, functions, types, and variables.  Reference
idents match the name of a declaration ident.  Type and identifier binding can
be done before conversion to core syntax, knowning only which type of ident is
used.  This can be annotated in the parser.

The list syntax should be extended to include identifier type annotation.
