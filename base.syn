goal:
| topStatements
| imports topStatements
;

imports: "import" "{" NEWLINE paths "}" NEWLINE -> ("import" $3)
;

paths: -> ()
| paths path NEWLINE -> $1.$2
;

path: IDENT -> $1:ref
| dottedPath
;

dottedPath: "(" idents ")" -> $2
;

idents: IDENT -> ($1:ref)
| idents IDENT -> $1.$2:dot
;

topStatements: statement NEWLINE -> ($1)
| topStatements statement NEWLINE -> $1.$2
;

statement: executableStatement
| declaration
;

statementList: "{" NEWLINE statements "}" -> $3:scoped
;

statements: -> ()
| statements statement NEWLINE -> $1.$2
;

executableStatement: assignStatement
| switchStatement
| callStatement
| returnStatement
| deleteStatement
| ifStatement
| whileStatement
;

assignStatement: accessExpr "=" expr -> ("=" $1 $3)
;

ifStatement: "if" boolExpr statementList optElse -> ("if" $2 $3 $4)
;

optElse:
| "else" statementList -> $2
;

whileStatement: "while" boolExpr optStatementList
    -> ("while" $2 $3)
| "do" statementList "while" boolExpr optStatementList
    -> ("do" $2 "while" $4 $5)
;

optStatementList:
| statementList
;

callStatement: functionCall
;

returnStatement: "return" optExpr -> ("return" $2)
;

optExpr:
| expr
;

deleteStatement: "delete" accessExpr -> ("delete" $2)
;

switchStatement: "switch" arithExpr NEWLINE cases optDefaultCase -> ("switch" $2).$3.$4
;

cases: case -> ($1)
| cases case -> $1.$2
;

case: "case" constArithExpr statementList -> ($2 $3)
;

optDefaultCase:
| "default" statementList -> ("default" $2)
;

declaration: varDecl
| functionDecl
| classDecl
;

varDecl: "var" type IDENT optInitializer -> ("var" $2 $3:def $4)
;

optInitializer:
| "=" expr -> $2
;

functionDecl: "func" type IDENT "(" functionParamDecls ")" statementList
    -> ("func" $2 $3:scoped $5 $7)
| "func" IDENT "(" functionParamDecls ")" statementList
    -> ("func" null $2:scoped $4 $6)
;

functionParamDecls: -> ()
| type IDENT -> ($1 $2:def)
| functionParamDecls "," type IDENT -> $1.$3.$4:def
;

classDecl: "class" IDENT "{" NEWLINE classDeclarations "}" NEWLINE -> ("class" $2:scoped).$5
;

classDeclarations: -> ()
| classDeclarations declaration NEWLINE -> $1.$2
;

functionCall: accessExpr "(" exprs ")" -> ($1)+$3
;

exprs: -> ()
| expr -> ($1)
| exprs "," expr -> $1.$2
;

type: path
| type "[" optSize "]" -> ("array" $1 $3)
;

optSize:
| INTEGER
;

accessExpr: IDENT -> $1:ref
| accessExpr "[" arithExpr "]" -> ("index" $1 $3)
| accessExpr "." IDENT -> ("dot" $1 $3:dot)
;

expr: boolOpExpr
| arithExpr
;

boolExpr: boolOpExpr
| accessExpr
| functionCall
;

boolOpExpr: andExpr
| boolOpExpr "||" andExpr -> ("||" $2 $3)
;

andExpr: notExpr
| notExpr "&&" andExpr -> ("&&" $1 $3)
;

notExpr: "!" basicBoolExpr -> ("!" $2)
| relationalExpr
;

basicBoolExpr: accessExpr
| "(" boolExpr ")" -> $2
;

relationalExpr: arithExpr relationalOp arithExpr -> ($2 $1 $3)
;

relationalOp: "=="
| "!="
| ">"
| "<"
| ">="
| "<="
;

arithExpr: addExpr
| mulExpr "<<" addExpr -> ("<<" $1 $3)
| mulExpr ">>" addExpr -> (">>" $1 $3)
;

addExpr: mulExpr
| addExpr "+" mulExpr -> ("+" $1 $3)
| addExpr "-" mulExpr -> ("-" $1 $3)
;

mulExpr: bitOrExpr
| mulExpr "*" bitOrExpr -> ("*" $1 $3)
| mulExpr "/" bitOrExpr -> ("/" $1 $3)
| mulExpr "%" bitOrExpr -> ("%" $1 $3)
;

bitOrExpr: bitXorExpr
| bitOrExpr "|" bitXorExpr
;

bitXorExpr: bitAndExpr
| bitXorExpr "^" bitAndExpr
;

bitAndExpr: unaryArithExpr
| bitAndExpr "&" unaryArithExpr
;

unaryArithExpr: basicArithExpr
| "-" basicArithExpr -> ("-" $2)
| "~" basicArithExpr -> ("~" $2)
;

basicArithExpr: accessExpr
| functionCall
| INTEGER
| FLOAT
| newExpr
| "(" expr ")"
;

constArithExpr: path
| INTEGER
;

newExpr: "new" path -> ("new" $2)
;
